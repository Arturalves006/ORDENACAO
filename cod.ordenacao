#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

//  MÉTRICAS 

typedef struct {
    long long steps_cmp;
    long long steps_swap;
} Metrics;

void reset_metrics(Metrics *m) {
    m->steps_cmp = 0;
    m->steps_swap = 0;
}

//  BUBBLE SORT 

void bubble_sort(int *v, size_t n, Metrics *m) {
    int temp;
    for (size_t i = 0; i < n - 1; i++) {
        for (size_t j = 0; j < n - 1 - i; j++) {
            m->steps_cmp++;
            if (v[j] > v[j + 1]) {
                m->steps_swap++;
                temp = v[j];
                v[j] = v[j + 1];
                v[j + 1] = temp;
            }
        }
    }
}

//  INSERTION SORT 

void insertion_sort(int *v, size_t n, Metrics *m) {
    for (int i = 1; i < (int)n; i++) {
        int chave = v[i];
        int j = i - 1;
        m->steps_cmp++;
        while (j >= 0 && v[j] > chave) {
            m->steps_cmp++;
            m->steps_swap++;
            v[j + 1] = v[j];
            j--;
        }
        m->steps_swap++;
        v[j + 1] = chave;
    }
}

//  SELECTION SORT 

void selection_sort(int *v, size_t n, Metrics *m) {
    for (size_t i = 0; i < n - 1; i++) {
        size_t min = i;
        for (size_t j = i + 1; j < n; j++) {
            m->steps_cmp++;
            if (v[j] < v[min]) min = j;
        }
        if (min != i) {
            m->steps_swap++;
            int temp = v[i];
            v[i] = v[min];
            v[min] = temp;
        }
    }
}

//  RUN SORT 

double run_sort(void (*fn)(int*,size_t,Metrics*), int *v, size_t n, Metrics *m) {
    reset_metrics(m);
    clock_t t0 = clock();
    fn(v, n, m);
    clock_t t1 = clock();
    return 1000.0 * (t1 - t0) / CLOCKS_PER_SEC;
}

//  MAIN 

void print_array(int *v, size_t n) {
    for (size_t i = 0; i < n; i++) {
        printf("%d", v[i]);
    }
    printf("\n");
}

int main() {
    char rgm_str[50];
    printf("Digite seu RGM: ");
    scanf("%s", rgm_str);

    size_t n_rgm = strlen(rgm_str);
    int v_rgm[50];

    for (size_t i = 0; i < n_rgm; i++) {
        v_rgm[i] = rgm_str[i] - '0';
    }

    Metrics m;
    int copia[50];


    //  RGM 

    // Bubble Sort
    memcpy(copia, v_rgm, n_rgm * sizeof(int));
    double t = run_sort(bubble_sort, copia, n_rgm, &m);
    printf("bubble,%zu,rgm,%lld,%.3f\n", n_rgm, m.steps_cmp + m.steps_swap, t);
    printf("RGM ordenado (Bubble): ");
    print_array(copia, n_rgm);

    // Insertion Sort
    memcpy(copia, v_rgm, n_rgm * sizeof(int));
    t = run_sort(insertion_sort, copia, n_rgm, &m);
    printf("insertion,%zu,rgm,%lld,%.3f\n", n_rgm, m.steps_cmp + m.steps_swap, t);
    printf("RGM ordenado (Insertion): ");
    print_array(copia, n_rgm);

    // Selection Sort
    memcpy(copia, v_rgm, n_rgm * sizeof(int));
    t = run_sort(selection_sort, copia, n_rgm, &m);
    printf("selection,%zu,rgm,%lld,%.3f\n", n_rgm, m.steps_cmp + m.steps_swap, t);
    printf("RGM ordenado (Selection): ");
    print_array(copia, n_rgm);

    //  VETORES ALEATÓRIOS 

    int tamanhos[] = {100, 1000, 10000};
    for (int idx = 0; idx < 3; idx++) {
        int N = tamanhos[idx];
        int *ale = malloc(N * sizeof(int));
        for (int i = 0; i < N; i++) ale[i] = rand() % 1000;

        // Bubble
        memcpy(copia, ale, N * sizeof(int));
        t = run_sort(bubble_sort, copia, N, &m);
        printf("bubble,%d,aleatorio,%lld,%.3f\n", N, m.steps_cmp + m.steps_swap, t);

        // Insertion
        memcpy(copia, ale, N * sizeof(int));
        t = run_sort(insertion_sort, copia, N, &m);
        printf("insertion,%d,aleatorio,%lld,%.3f\n", N, m.steps_cmp + m.steps_swap, t);

        // Selection
        memcpy(copia, ale, N * sizeof(int));
        t = run_sort(selection_sort, copia, N, &m);
        printf("selection,%d,aleatorio,%lld,%.3f\n", N, m.steps_cmp + m.steps_swap, t);

        free(ale);
    }

    return 0;
}
